{"1": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "2": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "3": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "4": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "5": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "6": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "7": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "8": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "9": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "10": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "11": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "12": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "13": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "14": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "15": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "16": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "17": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "18": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "19": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "20": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "21": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "22": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "23": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "24": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "25": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "26": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "27": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "28": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "29": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "30": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "31": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "32": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "33": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "34": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "35": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "36": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "37": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "38": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "39": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "40": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "41": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "42": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "43": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "44": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "45": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "46": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "47": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "48": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "49": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "50": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "51": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "52": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "53": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "54": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "55": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "56": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "57": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "58": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "59": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "60": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "61": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "62": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "63": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "64": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "65": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "66": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "67": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "68": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "69": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "70": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "71": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "72": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "73": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "74": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "75": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "76": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "77": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "78": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "79": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "80": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "81": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "82": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "83": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "84": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "85": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "86": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "87": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "88": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "89": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "90": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "91": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "92": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "93": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "94": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "95": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "96": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "97": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "98": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "99": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "100": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "101": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "102": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "103": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "104": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "105": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "106": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "107": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "108": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "109": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "110": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "111": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "112": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "113": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "114": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "115": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "116": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "117": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "118": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "119": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "120": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "121": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "122": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "123": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "124": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "125": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "126": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "127": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "128": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "129": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "130": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "131": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "132": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "133": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "134": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "135": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "136": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "137": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "138": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "139": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "140": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "141": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "142": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "143": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 1024;\n    const int N = 4096;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 128]}}, "144": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 4096;\n    const int K = 4096;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [128, 32]}}, "145": {"code": "__global__ void MatMul_TILE_BLOCK_GENERAL(float *input0, float *input1, float *input2, float *input3, float *output0){\n\tfloat *g_vec = input0;\n\tfloat *g_mat_data = input1;\n\tint *g_mat_index = (int*)input2;\n\tfloat *bias = input3;\n\tfloat *g_data = output0;\n\tconst float SPARSITY = 0.90625;\n    const int M = 32;\n    const int K = 1024;\n    const int N = 1024;\n    const int K_sparse = int(K * (1-SPARSITY));\n\n    const int BLOCK_SIZE_M = 32;\n    const int BLOCK_SIZE_N = 32;\n    // BLOCK_SIZE_K should > NUM_BANK\n    const int BLOCK_SIZE_K = 256;\n    const int THREAD_SIZE_M = 4;\n    const int THREAD_SIZE_N = 4;\n\n    const int ALIGN_N = BLOCK_SIZE_N;\n\n    const int BANK_VAL = 32;\n    const int NUM_BANK = K / BANK_VAL;\n\n    const int BANK_NUM_PER_BLOCK = BLOCK_SIZE_K / BANK_VAL;\n    const int BLOCK_SIZE_K_SPARSE = int(BLOCK_SIZE_K * (1-SPARSITY));\n    const int LEN_OF_BANK_PER_SPARSE_BLOCK = BLOCK_SIZE_K_SPARSE / BANK_NUM_PER_BLOCK;\n\n\tint M_BLOCK_START = blockIdx.x * BLOCK_SIZE_M;\n\tint N_BLOCK_START = blockIdx.y * BLOCK_SIZE_N;\n\n\t\n\n\tconst int A_THREADS_PER_ROW = BLOCK_SIZE_M / 4;\n\tconst int B_THREADS_PER_ROW = BLOCK_SIZE_N / 4;\n\n\tconst int THREADS_PER_BLOCK = (BLOCK_SIZE_M / THREAD_SIZE_M) * (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tconst int A_STRIDES = THREADS_PER_BLOCK / A_THREADS_PER_ROW;\n\tconst int B_STRIDES = THREADS_PER_BLOCK / B_THREADS_PER_ROW;\n\n\t__shared__ float A_shared[BLOCK_SIZE_M * BLOCK_SIZE_K_SPARSE];\n\t__shared__ float B_shared[BLOCK_SIZE_N * BLOCK_SIZE_K_SPARSE];\n\n\tfloat A_reg[THREAD_SIZE_M];\n\tfloat B_reg[THREAD_SIZE_N];\n\tfloat C_reg[THREAD_SIZE_N][THREAD_SIZE_M] = {0};\n\n\tint tid = threadIdx.x;\n\n\tint t_N = tid % (BLOCK_SIZE_N / THREAD_SIZE_N);\n\tint t_M = tid / (BLOCK_SIZE_N / THREAD_SIZE_N);\n\n\tint A_BLOCK_ROW_START = tid / A_THREADS_PER_ROW;\n\tint B_BLOCK_ROW_START = tid / B_THREADS_PER_ROW;\n\n\tint A_BLOCK_COL_START = tid % A_THREADS_PER_ROW * 4;\n\tint B_BLOCK_COL_START = tid % B_THREADS_PER_ROW * 4;\n\n\tfor(int K_BLOCK_START = 0, K_SPARSE_BLOCK_START = 0; K_BLOCK_START < K; K_BLOCK_START += BLOCK_SIZE_K, K_SPARSE_BLOCK_START += BLOCK_SIZE_K_SPARSE){\n\t\tfloat *A_global_ptr = g_vec + M_BLOCK_START;\n\t\tfloat *B_global_ptr = g_mat_data + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\t\tint *B_index_global_ptr = g_mat_index + K_SPARSE_BLOCK_START * N + N_BLOCK_START;\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += A_STRIDES){\n\t\t\tint idx = *(B_index_global_ptr + (i + A_BLOCK_ROW_START) * N);\n\t\t\t*(float4 *)(A_shared + (i + A_BLOCK_ROW_START) * BLOCK_SIZE_M + A_BLOCK_COL_START) = \n\t\t\t\t*(float4 *)(A_global_ptr + idx * M + A_BLOCK_COL_START);\n\t\t}\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += B_STRIDES){\n\t\t\t*(float4 *)(B_shared + (i + B_BLOCK_ROW_START) * BLOCK_SIZE_N + B_BLOCK_COL_START) =\n\t\t\t\t*(float4 *)(B_global_ptr + (i + B_BLOCK_ROW_START) * N + B_BLOCK_COL_START);\n\t\t}\n\n\t\t__syncthreads();\n\n\t\t#pragma unroll\n\t\tfor(int i = 0; i < BLOCK_SIZE_K_SPARSE; i += 1){\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_M; k += 1){\n\t\t\t\tA_reg[k] = A_shared[i * BLOCK_SIZE_M + t_M * THREAD_SIZE_M + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\tB_reg[k] = B_shared[i * BLOCK_SIZE_N + t_N * THREAD_SIZE_N + k];\n\t\t\t}\n\t\t\t#pragma unroll\n\t\t\tfor(int k = 0; k < THREAD_SIZE_N; k += 1){\n\t\t\t\t#pragma unroll\n\t\t\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\t\t\tC_reg[k][j] += B_reg[k] * A_reg[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#pragma unroll\n\tfor(int i = 0; i < THREAD_SIZE_N; i += 1){\n\t\t#pragma unroll\n\t\tfor(int j = 0; j < THREAD_SIZE_M; j += 1){\n\t\t\tg_data[(BLOCK_SIZE_N * blockIdx.y + THREAD_SIZE_N * t_N + i) * M + (BLOCK_SIZE_M * blockIdx.x + THREAD_SIZE_M * t_M + j)] =\n\t\t\t\tC_reg[i][j];\n\t\t}\n\t}\n}", "launch_config": {"dimBlock": [64, 1], "dimGrid": [1, 32]}}}